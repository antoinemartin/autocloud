{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Autocloud: GitOps Kubernetes Bootstrapper","text":"<p>Welcome to Autocloud!</p> <p>This repository contains the components allowing you to get a GitOps managed Kubernetes cluster ready in minutes.</p> <p>With a simple and elegant solution for the GitOps \"Chicken and egg\" problem, it eases the bootstrapping of a Kubernetes environment.</p> <p>To developers, Autocloud provides a development environment very close to production.</p> <p>For Devops and SREs, Autocloud is a blueprint that can be used as a base to setup a GitOps based engineering platform.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Kubernetes distribution and Clouder independent.</li> <li>GitOps through ArgoCD.</li> <li>Auto-managed. Once deployed, the base components are managed through GitOps.</li> <li>No custom CLI or configuration. Use only the tools that you already use.</li> <li>You can deploy it on your development laptop, on a managed cluster or on a     cloud VM.</li> <li>User management through GitHub or any other OIDC source.</li> <li>Secrets management via SOPS.</li> <li>Simple architecture allowing components to be easily deactivated or     replaced.</li> <li>Ingress (Traefik) and Load Balancing provided.</li> <li>Getting the best of Kustomize and Helm (and even Helmfile).</li> <li>Your development machine can receive webhooks.</li> </ul>"},{"location":"#similar-projects","title":"Similar projects","text":"<p>Argo CD Autopilot deploys an Argo CD installation and creates the application allowing to auto-manage the installation through a GitHub repository. However, it relies on a CLI that adds a tool in your bag and doesn't provide solutions for ingress, authentication, ...</p> <p>Kubefirst also comes with a CLI. For local development, it's tied with K3d, that means to K3s and docker. It's currently only compatible with AWS. It also makes some other opinionated choices (Vault, ...). As with Autopilot, the bootstrapping is not GitOps. It's handled by the CLI and You don't get to review first what is going to happen.</p>"},{"location":"architecture/","title":"Architecture","text":"<p>The following diagram shows the architecture:</p> <p></p> <ul> <li>Github (or Gitlab) provides the gitops repository as well as the     authentication through OIDC.</li> <li>If the cluster doesn't have a direct access to the internet, which is the     case if it is running on your development machine behind a firewall, a     cloudflare tunnel (or sish) provides online presence.</li> <li>The tunnel redirects HTTP/HTTPS traffic to traefik (or apisix) that acts     as an ingress controller.</li> <li>External DNS and Cert-Manager manage the domain name routing and the     let's encrypt certificates generation and renewal.</li> <li>When running on a vanilla kubernetes created by kubeadm, uninode provides     the basic services (Ingress, Load balancer, storage, metrics...).</li> </ul>"},{"location":"architecture/#bootstrapping-stages","title":"Bootstrapping stages","text":"<p>The following diagram summarizes the bootstrapping of the cluster:</p> <pre><code>---\ntitle: Cluster bootstrap\n---\nflowchart TD\n  A[Start] --&gt; AA[Apply Argo CD kustomization];\n  AA --&gt; B{{Deploy Argo CD}};\n  B --&gt; C&gt;End];\n  C --&gt; |Yes| D(add bootstrap app);\n  D --&gt; E(add traefik app);\n  D --&gt; E2(add argocd app);\n  E2 -.-&gt; B;\n  D --&gt; F[add uninode app];\n  E --&gt; dtr{{Deploy traefik}}\n  F --&gt; dml{{Deploy MetalLB}}\n  F --&gt; dfl{{Deploy Flannel}}\n  F --&gt; dls{{Deploy Local storage}}\n  F --&gt; dms{{Deploy Metrics server}}\n  dml --&gt; end2&gt;End];\n  dfl --&gt; end2&gt;End];\n  dls --&gt; end2&gt;End];\n  dms --&gt; end2&gt;End];\n  dtr --&gt; end2&gt;End];\n  end2 --&gt; apps(add apps app)\n  apps --&gt; other(add other apps ...)\n</code></pre> <p>The bootstrapping of the cluster is like a domino:</p> <ol> <li>First the Argo CD kustomization is applied from outside the cluster.</li> <li>In the kustomization, there is a job that waits for the deployment of Argo     CD to settle. When it's done, it adds the <code>bootstrap</code> application.</li> <li>The <code>bootstrap</code> application points to a directory containing other     applications. One of them points back to the Argo CD kustomization in the     repo. Since it has already been deployed, nothing happens. But in the future     if Argo CD detects a change in the kustomization in the repo, it will auto     apply it to itself.</li> <li>The other applications of the <code>apps/bootstrap</code> directory install base     services that are required to go further: <code>uninode</code> installs what is needed     on a development cluster to use Storage, LoadBalanced services, Network and     Auto-scaling. <code>traefik</code> provides the ingress controller.</li> <li>After the previous applications have settled, the <code>apps</code> application is     applied to start the next stage. This application point to another     applications directory, <code>apps/default</code>, containing the second stage of     base services:<ul> <li><code>ingresses</code> deploy ingresses to access Argo CD from internet.</li> <li><code>cert-manager</code> deploys cert-manager.</li> <li><code>external-dns-ovh</code> deploys external DNS using OVH API for OVH domains.</li> <li><code>external-dns-cloudflare</code> deploys external DNS using Cloudflare API for     Cloudflare domains.</li> <li><code>cloudflare-client</code> installs the Cloudflare tunnel client.</li> <li><code>sish-client</code> installs the sish tunnel client.</li> </ul> </li> </ol>"},{"location":"components/","title":"Introduction","text":"<p>This section provides information about the different components used by the solution.</p> <p>The following list enumerates all components.</p> <ul> <li>Argo CD</li> <li>kubectl</li> <li>Helm</li> <li>SOPS</li> <li>Age</li> <li>Traefik</li> <li>Certificate-Manager</li> <li>External DNS (Not yet)</li> <li>Sish</li> <li>Chisel</li> </ul>"},{"location":"components/#uninode-related-components","title":"Uninode related components","text":"<p>The following are components that are typically already installed in any managed Kubernetes cluster flavor.</p> <ul> <li>MetalLB</li> <li>Flannel</li> <li>Local Path storage</li> <li>Metrics server</li> </ul>"},{"location":"components/argo-cd/","title":"Argo CD","text":"<p>TODO</p> <p>Fill this page.</p>"},{"location":"components/sish/","title":"SISH","text":"<p>TODO</p> <p>Fill this page.</p>"},{"location":"components/sops/","title":"SOPS","text":"<p>TODO</p> <p>Fill this page.</p> <p>The bootstrapping of secrets.</p> <p>SOPS allows keeping secrets inside the source code.</p>"},{"location":"getting-started/1-pre-requisites/","title":"Pre-requisites","text":""},{"location":"getting-started/1-pre-requisites/#software","title":"Software","text":"<ul> <li>kubectl to apply resources to     your cluster.</li> <li>sops for secrets management. age     is a nice addition if you want to use AGE keys to encrypt secrets     (recommended).</li> <li>kustomize for aggregating and adapting resources.     <code>kubectl</code> includes <code>kustomize</code> (<code>kustomize</code> subcommand and <code>-k</code> option) but     it only allows running KRM functions as docker containers. This creates an     impractical dependency on docker. This is why we use the Exec KRM     functions model. To use it, however, the <code>kustomize</code> standalone binary is     required.</li> <li>krmfnbuiltin is a swiss army knife KRM function allowing us     to perform structural modifications to the resources of the environment.     Think of it as <code>sed</code>, but for Kubernetes resources. Also knows how to     decrypt sops encrypted KRM resources.</li> <li>Kubeconform performs validation of     Kubernetes resources. It is useful to check kustomization output.</li> </ul> <p>Todo</p> <p>Provide already configured environments:</p> <ul> <li>Docker container (can be argocd custom image. age is missing)</li> <li>WSL distribution (can be derived from the docker image)</li> <li>LXC root filesystem</li> </ul>"},{"location":"getting-started/1-pre-requisites/#online-git-provider-account","title":"Online git provider account","text":"<p>Autocloud is hosted on GitHub and currently uses the following features:</p> <ul> <li>OAuth Apps     to provide authentication to the Argo CD Web UI.</li> <li>Webhook     to trigger cluster update immediately.</li> <li>Deployment keys     to allow repository read-only restricted access for Argo CD.</li> </ul> <p>Gitlab provides the same features and can probably be used as well.</p> <p>Gittea support</p> <p>Supporting Air gapped developments with a cluster hosted Gittea server is planned.</p>"},{"location":"getting-started/1-pre-requisites/#kubernetes-cluster","title":"Kubernetes cluster","text":"<p>To deploy autocloud, you need a Kubernetes cluster. Autocloud is originally used and tested with a vanilla Kubernetes cluster created with kubeadm, running on an Alpine based VM or WSL2 distribution. The deployment of such a cluster is made easy by using the iknite package. On Windows, kaweezle makes this deployment even easier.</p> <p>In such mono-node deployment configuration, autocloud provides an uninode kustomization and Argo CD application providing basic configuration (CNI, storage, metrics, Load Balancer).</p> <p>Most lightweight developer oriented Kubernetes distribution like Kind, K3s, MicorK8s or Rancher Desktop as well as all managed clusters already provide such services. Fortunately, autocloud provides an easy way to deactivate uninode.</p> <p>Note</p> <p>In this documentation, we will use K3s, that seems to be currently the most popular solution as an example.</p>"},{"location":"getting-started/1-pre-requisites/#cloud-provider-accounts","title":"Cloud provider account(s)","text":"<p>If you want to get the most out of Autocloud, You will need at least the following:</p> <ul> <li>A registered domain name. Make sure that your domain name provider has an     API that is known to External DNS and Cert-Manager.     OVH, for instance, offers domain     names for 1,99\u20ac (without VAT) on its <code>.ovh</code> TLD.     Cloudflare promises no     markup on their end. With them a <code>.com</code> is less that 10$ a year.</li> <li>To be able to run Autocloud behind a firewall as if it was running in a     cloud provider, a tunnelling solution is needed. Cloudflare has a free tier     on its tunnel offering that     you can use with a domain that has been registered with them. Tailscale     also offers a free tier. inlets and     ngrok are not cheap. We provide simple Open Source     solutions (sish, chisel) if the case that you can deploy software somewhere     in the cloud.</li> <li>S3 compatible storage. While you can use Minio, external storage is useful     for backups and shared storage. Cloudflare as a free tier     for starters and doesn't charge for egress traffic. There are too other     numerous solutions to list. Nowadays, everyonec is S3 compatible.</li> </ul> <p>Note</p> <p>In this documentation, we will use Cloudflare as it provides the three components above. This is not a recommendation. Furthermore, autocloud provides kustomizations for some of the other providers (OVH, for instance).</p>"},{"location":"getting-started/1-pre-requisites/#ide-integration","title":"IDE Integration","text":"<p>Autocloud provides helpful additions if you are using Visual Studio Code as your IDE:</p> <ul> <li>Plugins recommendations.</li> <li>Tasks (see <code>.vscode/tasks.json</code>).</li> </ul> <p>Once you have all these elements, proceed to the GitOps setup.</p>"},{"location":"getting-started/2-gitops-setup/","title":"2. Gitops setup","text":""},{"location":"getting-started/2-gitops-setup/#setup-the-gitops-environment","title":"Setup the GitOps environment","text":"<p>Todo</p> <p>Provide a Terraform script for this.</p> <p>Setting up you GitOps environment involves the following tasks:</p> <ul> <li>Fork (public) or Import (private) the Autocloud repository on your     personal account or organization.</li> <li>Create a deployment branch that will be tracked by Argo CD.</li> </ul> <p>There are other tasks, potentially optional, related to te repository, but as they involve credentials, they are covered after changing the encryption keys in the environment adaptation:</p> <ul> <li>Create a     deployment key     on the repository if the repository is going to be private.</li> <li>Create an OAuth Application on your account or organization to allow     github based authentication on Argo CD. This is optional.</li> <li>Creating a     webhook     on the repository targeting Argo CD for faster updates.</li> </ul> <p>Info</p> <p>In the following, we are going to assume that the destination is an organization named klasmik and that the repository, named <code>klasmikloud</code> is being kept private.</p>"},{"location":"getting-started/2-gitops-setup/#fork-the-repository","title":"Fork the repository","text":""},{"location":"getting-started/2-gitops-setup/#on-githubcom","title":"On github.com","text":"<p>If you plan to keep your repository public, fork the public Autocloud repository into your own account or organization:</p> <p></p> <p>In the case you want to make the repo private, it's better to import it instead. Click on the  icon in the top right corner and choose Import repository:</p> <p></p>"},{"location":"getting-started/2-gitops-setup/#from-the-command-line","title":"From the command line","text":"<p>This also can be done from the command line:</p> ShellPowerShell <pre><code>&gt; gh repo create klasmik/klasmikloud --private\n&gt; git clone --bare --single-branch https://github.com/antoinemartin/autocloud.git\n&gt; git --git-dir=autocloud.git push --mirror git@github.com:klasmik/klasmikloud.git\n&gt; rm -rf autocloud.git\n</code></pre> <pre><code>PS&gt; gh repo create klasmik/klasmikloud --private\nPS&gt; git clone --bare --single-branch https://github.com/antoinemartin/autocloud.git\nPS&gt; git --git-dir=autocloud.git push --mirror git@github.com:klasmik/klasmikloud.git\nPS&gt; Remove-Item autocloud.git -Recurse -Force\n</code></pre>"},{"location":"getting-started/2-gitops-setup/#clone-the-repository-and-create-a-deployment-branch","title":"Clone the repository and create a deployment branch","text":"<p>Following the GitOps principles, each deployment lives in its own branch. Clone the repository and create a deployment branch for your development environment (replace <code>klasmik/klasmikloud</code> with your organization and project name):</p> ShellPowerShell <pre><code>$ git clone git@github.com:klasmik/klasmikloud.git\n$ cd klasmikloud\n$ git checkout -b deploy/devenv\n$\n</code></pre> <pre><code>PS&gt; git clone git@github.com:klasmik/klasmikloud.git\nPS&gt; cd klasmikloud\nPS&gt; git checkout -b deploy/devenv\nPS&gt;\n</code></pre> <p>Once on the proper branch, you can now continue and change the encryption key.</p>"},{"location":"getting-started/3-change-encryption-key/","title":"Change the secrets encryption key","text":"<p>All the platform secrets are located in the <code>secrets/secrets.yaml</code> and encrypted with [sops ].</p> <p>On the main branch this file is encrypted by a sample age key located at the root of the project (<code>sample_age_key.txt</code>) and contains fake secrets. While you can use this sample key for testing, it's better to change it before doing anything with the secrets file.</p> <p>Start by making the sample age key reachable to sops by putting it in its well-known location:</p> ShellPowerShell <pre><code>$ mkdir -p ~/.config/sops/age\n$ cat sample_age_key.txt &gt;&gt; ~/.config/sops/age/keys.txt\n</code></pre> <pre><code>PS&gt; New-Item -Path $env:APPDATA\\sops\\age -ItemType Directory\nPS&gt; Copy-Item .\\sample_age_key.txt $env:APPDATA/sops/age/keys.txt\n</code></pre> <p>Note</p> <p>The following shows a rotation with a new Age key. Note that you can use any other key that sops understands. Check the sops documentation. You can also add other type of keys later on. We recommend to continue to use age at this stage.</p> <p>Then create your own key:</p> ShellPowerShell <pre><code>$ age-keygen &gt;&gt; ~/.config/sops/age/keys.txt\nPublic key: age1...\n</code></pre> <pre><code>PS&gt; age-keygen &gt;&gt; $env:APPDATA\\sops\\age\\keys.txt\nPublic key: age1...\n</code></pre> Derive the age key from a ssh key <p>The age key can be derived from a ssh key. This is convenient as a SSH key may be used to access the repository.</p> <p>The ssh-to-age project provides a command to convert an existing ed25519 ssh key into a valid age key:</p> <pre><code>$ go install github.com/Mic92/ssh-to-age/cmd/ssh-to-age@latest\n$ ssh-to-age -private-key -i ~/.ssh/id_ed25519 &gt;&gt; ~/.config/sops/age/keys.txt\n$ NEWKEY=$(ssh-to-age -i ~/.ssh/id_ed25519.pub)\n</code></pre> <p>Note that at the time of this writing, there is a PR in sops adding native ssh key support to sops.</p> <p>Replace the secrets encryption by using the public key of your new key (recipient in age parlance) with the following commands:</p> ShellPowerShell <pre><code>$ OLDKEY=$(age-keygen -y ~/.config/sops/age/keys.txt | head -1)\n$ NEWKEY=$(age-keygen -y ~/.config/sops/age/keys.txt | tail -1)\n$ for f in secrets/secrets.yaml secrets/helm/*; do \\\n&gt; sops -r -i \\\n&gt; --add-age $NEWKEY \\\n&gt; --rm-age $OLDKEY \\\n&gt; $f ; done\n$\n</code></pre> <pre><code>PS&gt; $OLDKEY=age-keygen.exe -y $env:APPDATA\\sops\\age\\keys.txt | Select-Object -First 1\nPS&gt; $NEWKEY=age-keygen.exe -y $env:APPDATA\\sops\\age\\keys.txt | Select-Object -Last 1\nPS&gt; $(ls .\\secrets\\secrets.yaml;ls .\\secrets\\helm\\*) | `\n&gt; % { &amp;sops '-r' '-i' '--add-age' $NEWKEY '--rm-age' $OLDKEY $_.FullName }\nPS&gt;\n</code></pre> <p>Now change the recipient in the <code>.sops.yaml</code> sops configuration file in order to use the new key for encryption from now on:</p> ShellPowerShell <pre><code>$ sed -i -e \"s/age: .*/age: $NEWKEY/\" .sops.yaml\n$\n</code></pre> <pre><code>...\nPS&gt; $(get-content .\\.sops.yaml | % { $_ -replace 'age: .*', \"age: $NEWKEY\" }) | `\n&gt; Set-Content .\\.sops.yaml\nPS&gt;\n</code></pre> <p>At this point, you can delete the sample key on your branch and commit the modifications:</p> ShellPowerShell <pre><code>$ rm sample_age_key.txt\n$ git add -A\n$ git commit -m \"\ud83d\udd10 Secrets encryption key modification\"\n</code></pre> <pre><code>...\nPS&gt; Remove-Item sample_age_key.txt\nPS&gt; git add -A\nPS&gt; git commit -m \"\ud83d\udd10 Secrets encryption key modification\"\n</code></pre> <p>From now on, you should forget the old key and make sure that you keep the new key safe. A good idea is to save it in some kind of secure password manager like gopass.</p> <p>To remove the old key from the sops well-known location, issue the following command:</p> ShellPowerShell <pre><code>&gt;  sed -i -e '1,3 d' ~/.config/sops/age/keys.txt\n</code></pre> <pre><code>PS&gt; Get-Content $env:APPDATA\\sops\\age\\keys.txt | Select-Object -Skip 3 `\n&gt; | Set-Content $env:APPDATA\\sops\\age\\keys.txt\n</code></pre> <p>Test that your environment is correct by decrypting the secrets file:</p> ShellPowerShell <pre><code>$ sops -d secrets/secrets.yaml &gt; secrets/secrets.dec.yaml\n$\n</code></pre> <pre><code>...\nPS&gt; sops -d secrets/secrets.yaml &gt; secrets/secrets.dec.yaml\nPS&gt;\n</code></pre> <p>.gitignore safe</p> <p>the project <code>.gitignore</code> file contains the <code>*.dec.yaml</code> pattern. Therefore, there is no risk of committing an unencrypted secrets file as long as you keep it named like that.</p> <p>You can also build the secrets kustomization. It will print out all the unencrypted secrets to the terminal:</p> ShellPowerShell <pre><code>$ kustomize build --enable-alpha-plugins --enable-exec secrets\n...\n</code></pre> <pre><code>...\nPS&gt; kustomize build --enable-alpha-plugins --enable-exec secrets\n...\n</code></pre> <p>Now that you can manage properly secured credentials, move on to the environment adaptation</p>"},{"location":"getting-started/4-environment-adaptation/","title":"Environment adaptation","text":""},{"location":"getting-started/4-environment-adaptation/#introduction","title":"Introduction","text":"<p>Adapting the environment involves the following tasks:</p> <ul> <li>Adapt the secrets file <code>secrets/secrets.yaml</code> and the properties file     <code>values.yaml</code> to the target environment.</li> <li>Apply the defined properties to the applications and kustomizations. That     means make the structural replacements in the resources for the defined     properties.</li> <li>Select the applications to be deployed in the target environment.</li> </ul> <p>The secrets are in <code>secrets/secrets.yaml</code> and the properties in <code>values.yaml</code>. They live in separate files for several reasons:</p> <ul> <li>The secrets are encrypted using sops whereas the properties are kept in     plain text.</li> <li>The properties are applied before committing. Secrets are opaque so     having any value in the files is not that important. To the contrary, having     actual values for other properties allows browsing of the repo without the     need to always refer to the centralized <code>values.yaml</code>. Therefore, the     applications and kustomizations contain the actual property values.     Applying from a centralized file is just a convenience to ease adaptation     and avoid oversights (see the     properties documentation).</li> <li>The kustomizations contain plain text fake secrets. They are     replaced with actual values in the cluster while the kustomizations     are built. Unencrypted values are injected in the kustomization by     <code>krmfnbuiltin</code> (more information in the user guide).</li> </ul>"},{"location":"getting-started/4-environment-adaptation/#adapt-secrets-and-properties","title":"Adapt secrets and properties","text":"<p>First you need an unencrypted secrets file. If you are comming from the previous step this is already the case. If not, issue the following command:</p> ShellPowerShell <pre><code>$ sops -d secrets/secrets.yaml &gt; secrets/secrets.dec.yaml\n$\n</code></pre> <pre><code>...\nPS&gt; sops -d secrets/secrets.yaml &gt; secrets/secrets.dec.yaml\nPS&gt;\n</code></pre>"},{"location":"getting-started/4-environment-adaptation/#cluster-identifier-and-domain-name","title":"Cluster identifier and domain name","text":"<p>The first properties of the <code>values.yaml</code> file contain global information about the cluster:</p> <pre><code>data:\ncluster:\nid: klasmikloud\ndnsZone: klasmik.com\nargocd:\ndomainPrefix: argocd-devenv\n</code></pre> <p><code>id</code> is the identifier of the cluster. <code>dnsZone</code> is the global domain name used by the cluster. <code>argocd.domainPrefix</code> allows the composition of the Argo CD UI domain name. In our example, it will be <code>argocd-devenv.klasmik.com</code>.</p>"},{"location":"getting-started/4-environment-adaptation/#secrets-encryption-key","title":"Secrets encryption key","text":"<p>Argo CD, When building kustomizations, need to have access to a decryption key to be able to decrypt the <code>secrets/secrets.yaml</code> file in order to inject secrets. This key is the key that you have created in the previous step and that is located in <code>~/.config/sops/age/keys.txt</code> (or <code>$env:APPDATA\\sops\\age\\keys.txt</code> on Windows)</p> <p>Put this key under <code>data.sops.age_key\\.txt</code> in <code>secrets/secrets.dec.yaml</code>:</p> <pre><code># secrets/secrets.dec.yaml\ndata:\n#...\nsops:\nage_key.txt: |-\n# created: 2023-01-19T19:41:45Z\n# public key: age166k86d56ejs2ydvaxv2x3vl3wajny6l52dlkncf2k58vztnlecjs0g5jqq\nAGE-SECRET-KEY-15RKTPQCCLWM7EHQ8JEP0TQLUWJAECVP7332M3ZP0RL9R7JT7MZ6SY79V8Q\n</code></pre>"},{"location":"getting-started/4-environment-adaptation/#repositiory-access","title":"Repositiory access","text":"<p>Optional</p> <p>This is only needed if your repository is private.</p> <p>To allow Argo CD to access the private repository, you can either use a deploy key or a Personal Access Token. The later is only interesting for accessing several repositories with the same credentials but is weaker in terms of security. For the initial setup, reading access to the autocloud repo is the only thing that we need. So for now, we will move forward with a deploy key.</p> <p>Create a SSH key with the following command:</p> ShellPowerShell <pre><code>$ ssh-keygen -N \"\" -C autocloud -q -t ed25519 -f autocloud\n$ cat autocloud.pub\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOqETmwadG+AtnC3HvdT66SIcilJIZdaRIrSRETHK1fU autocloud\n$\n</code></pre> <pre><code>PS&gt; # Note the backquotes before the double quotes\nPS&gt; ssh-keygen.exe -q -C autocloud -t ed25519 -N `\"`\" -f autocloud\nPS&gt; type autocloud.pub\nssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIOqETmwadG+AtnC3HvdT66SIcilJIZdaRIrSRETHK1fU autocloud\nPS&gt;\n</code></pre> <p>And then add it to the repo with the github CLI:</p> <pre><code>&gt;  gh repo deploy-key add autocloud.pub --title autocloud\n</code></pre> <p>You can also do it on github.com. Go to the following URL:</p> <pre><code># In our case, https://github.com/klasmik/klasmikloud/settings/keys/new\nhttps://github.com/&lt;organization&gt;/&lt;project&gt;/settings/keys/new\n</code></pre> <p>And enter the public key:</p> <p></p> <p>Info</p> <p>Argo CD will only use this key to clone the repository. Allowing write access is not required.</p> <p>Now test the key:</p> ShellPowerShell <pre><code>$ ssh -i ./autocloud git@github.com\nPTY allocation request failed on channel 0\nHi klasmik/klasmikloud! You've successfully authenticated, but GitHub does not provide shell access.\nConnection to github.com closed.\n$\n</code></pre> <pre><code>PS&gt; ssh -i autocloud git@github.com\nPTY allocation request failed on channel 0\nHi klasmik/klasmikloud! You've successfully authenticated, but GitHub does not provide shell access.\nConnection to github.com closed.\nPS&gt;\n</code></pre> <p>Now save the private key in the <code>secrets/secrets.dec.yaml</code> in the <code>github.ssh_key</code> key:</p> <pre><code>data:\n# ...\ngithub:\n# ...\nssh_key: |-\n-----BEGIN OPENSSH PRIVATE KEY-----\nb3BlbnNza...\n... SpbRCCLhgXt42GirPwlUAAAACWF1dG9jbG91ZAECAwQ= \n-----END OPENSSH PRIVATE KEY-----\n</code></pre>"},{"location":"getting-started/4-environment-adaptation/#argo-cd-authentication","title":"Argo CD Authentication","text":"<p>The Argo CD Autocloud installation comes with a local admin user and with Dex to allow SSO from an exiting OIDC source. In its initial configuration the SSO is done through github with all users of the specified organization as admins.</p>"},{"location":"getting-started/4-environment-adaptation/#local-admin-password","title":"Local admin password","text":"<p>Choose an admin password (hard to guess, easy to remember) and put it in the <code>secrets/secrets.dec.yaml</code> file under the <code>data.argocd.admin_password</code> key:</p> <pre><code># secrets/secrets.dec.yaml\ndata:\n# ...\nargocd:\nadmin_password: password\n</code></pre>"},{"location":"getting-started/4-environment-adaptation/#github-oidc-authentication","title":"Github OIDC authentication","text":"<p>Optional</p> <p>This is only needed if your want to authenticate to Argo CD with a github account.</p> <p>More details are available in the GitHub documentation about OAuth Apps.</p> <p>Go to <code>https://github.com/organizations/&lt;organization&gt;/settings/applications/new</code> and create the OAuth application according to the following:</p> <p></p> <p>Use the prefix (here <code>argocd-devenv</code>) that you plan to use for the Argo CD Web UI and the domain name (here <code>klasmik.com</code>) that you plan to use for the access to the cluster through the cloud.</p> <p>Once the application is created, copy the Client ID in the <code>data.github.clientID</code> of the properties.yaml file:</p> <pre><code>data:\n# ...\ngithub:\n# ...\nclientID: f3f29986cc0c4608ce03\n</code></pre> <p>Click on the <code>Generate a new client secret</code>.</p> <p></p> <p>Copy the value in the <code>secrets/secrets.dec.yaml</code> file under the <code>data.github.oauth_client_secret</code>:</p> <pre><code>data:\n# ...\ngithub:\n# ...\noidc_client_secret: d84...\n</code></pre> <p>Autocloud configures Argo CD to let in users pertaining to a particular organization. You need to specify the organization name in the <code>values.yaml</code> file under the <code>github</code> key:</p> <pre><code>data:\n# ...\ngithub:\norganization: klasmik\n</code></pre>"},{"location":"getting-started/4-environment-adaptation/#argo-cd-webhook-update","title":"Argo CD Webhook update","text":"<p>Optional</p> <p>This is if you want near realtime deployment and if Argo CD is accessible through internet.</p> <p>Argo CD checks the git repositories every 3 minutes for updates. To trigger the updates as soon as the modifications are pushed, it is convenient to add a webhook to the repository. The webhook will notify Argo CD to trigger the modification check immediately.</p> <p>Create a webhook according to the Argo CD webhook documentation. Go to</p> <pre><code># In our case, https://github.com/klasmik/klasmikloud/settings/hooks\nhttps://github.com/&lt;organization&gt;/&lt;epo&gt;/settings/hooks\n</code></pre> <p>Click on the <code>Add webhook</code> button on the top right:</p> <p></p> <p>Enter a secret. The same secret needs to be inserted in the <code>secrets/secrets.dec.yaml</code> file in the <code>data.github.webhook_secret</code> key:</p> <pre><code>data:\n# ...\ngithub:\n# ...\nwebhook_secret: 3Ab...\n</code></pre>"},{"location":"getting-started/4-environment-adaptation/#dns-provider-api-credentials","title":"DNS provider API credentials","text":"<p>Autocloud currently supports two DNS providers: OVH and Cloudflare. Each of them is configured in its respective <code>ovh</code> and <code>cloudflare</code> sections.</p> <p>In <code>values.yaml</code>:</p> <pre><code># values.yaml\ndata:\ncloudflare:\nemail: john@doe.me\ndnsZone: klasmik.com\novh:\nendpoint: ovh-eu\napplicationKey: iYrnuWulPIzRIYZP\ndnsZone: develop.cx\n</code></pre> <p>In <code>secrets.yaml</code>:</p> <pre><code>data:\ncloudflare:\napiKey: e...\novh:\napplication_secret: E...\nconsumer_key: l...\n</code></pre> <p>For OVH, the API access credentials can be created at the following address: https://www.ovh.com/auth/api/createToken</p> <p>For Cloudflare, you need to retrieve your API token at the following page: https://dash.cloudflare.com/profile/api-tokens</p>"},{"location":"getting-started/4-environment-adaptation/#online-presence","title":"Online presence","text":""},{"location":"getting-started/4-environment-adaptation/#cloudflare-tunnel","title":"Cloudflare tunnel","text":"<p>To setup the cloudflare tunnel, the best option is from the command line with the help of the <code>cloudflared</code> CLI. To install it, follow the instructions in the cloudflared documentation</p> <p>Start with login:</p> <pre><code>&gt; cloudflared tunnel login\nPlease open the following URL and log in with your Cloudflare account:\nhttps://dash.cloudflare.com/argotunnel?callback=https%3A%2F%2Flogin.cloudflareaccess.org%2F_P_LYLgTz4vuQtxb_BpRhZ3-0KipIrOlyZoX8XxhyFQ%3D\n\nLeave cloudflared running to download the cert automatically.\n2023-02-09T18:27:21Z INF Waiting for login...\n</code></pre> <p>Choose you domain name and validate it:</p> <p></p> <p>the login ends in the terminal:</p> <pre><code>...\n2023-02-09T18:27:21Z INF Waiting for login...\nYou have successfully logged in.\nIf you wish to copy your credentials to a server, they have been saved to:\n/root/.cloudflared/cert.pem\n&gt;\n</code></pre> <p>Then create the tunnel:</p> <pre><code>&gt; cloudflared tunnel create klasmikloud\nTunnel credentials written to /root/.cloudflared/b3d4c50f-94a7-4d2d-a5a2-b16dbdad6db6.json. cloudflared chose this file based on where your origin certificate was found. Keep this file secret. To revoke these credentials, delete the tunnel.\nCreated tunnel klasmikloud with id b3d4c50f-94a7-4d2d-a5a2-b16dbdad6db\n&gt;\n</code></pre> <p>The id printed goes in the <code>data.cloudflare.tunnel_id</code> property of the <code>values.yaml</code> file:</p> <pre><code># values.yaml\ndata:\n# ...\ncloudflare:\nemail: antoine@openance.com\ndnsZone: klasmik.com\nhostName: '*.klasmik.com'\ntunnel_id: b3d4c50f-94a7-4d2d-a5a2-b16dbdad6db\n</code></pre> <p>The contents of the json file mentioned in the command output (here <code>/root/.cloudflared/b3d4c50f-94a7-4d2d-a5a2-b16dbdad6db6.json</code>) go in the <code>secrets/secrets.yaml</code> file in the <code>data.cloudflare.credentials\\.json</code> property:</p> <pre><code># secrets/secrets.dec.yaml\ndata:\ncloudflare:\ncredentials.json: |\n{\"AccountTag\":\"a...\",\"TunnelSecret\":\"p...\",\"TunnelID\":\"b3d4c50f-94a7-4d2d-a5a2-b16dbdad6db6\"}\n</code></pre> <p>you also need to associate your domain name with the tunnel with the following command:</p> <pre><code>&gt; cloudflared tunnel route dns klasmikloud argocd-devenv.klasmik.com\n2023-02-09T19:00:16Z INF Added CNAME argocd-devenv.klasmik.com which will route to this tunnel tunnelID=b3d4c50f-94a7-4d2d-a5a2-b16dbdad6db6\n&gt;\n</code></pre> <p>If you go to the DNS configuration of your domain name, you will see the <code>CNAME</code> record:</p> <p></p> <p>TLS termination</p> <p>With this configuration, and in particular the fact that the CNAME is proxied, the TLS termination of the domain name is handled by cloudflare.</p>"},{"location":"getting-started/4-environment-adaptation/#sish","title":"Sish","text":"<p>sish enables online presence for the cluster by using the ssh protocol. Sish offers several advantages:</p> <ul> <li>The client is a standard ssh client.</li> <li>The server supports SNI. You can have multiple subdomains and domain names     on the same server.</li> <li>As authentication is done through ssh keys, you can leverage existing     infrastructure. For instance you can use the github keys API to feed your     server with authorized keys.</li> </ul> <p>There is more information in the sish component page.</p> <p>For the configuration, you will need the following values:</p> <pre><code>sish:\nhostname: develop.cx\nremote: argocd-devenv.develop.cx\n# This is the public key of the private ed25519 key in ../secrets/helm/sish.yaml\nhost_key: AAAAC3NzaC1lZDI1NTE5AAAAIEAfLUpTj0fn5sJFW6agmLMsvEacMBvXocyzHLW+AOSQ\n</code></pre> <p><code>hostname</code> is the address of the sish server. <code>remote</code> is the full domain name that needs to be redirected locally. <code>host_key</code> is the public key of the host.</p> <p>The only secret is the ssh private key to connect to the server:</p> <pre><code>sish:\nssh_key: |\n-----BEGIN OPENSSH PRIVATE KEY-----\nb3B...\n...FBg==\n-----END OPENSSH PRIVATE KEY-----\n</code></pre> <p>This key needs to be registered in a github account so that the URL <code>https://github.com/&lt;account&gt;.keys</code> returns the public key. The name of the github account needs to be passed to the deployment of the <code>sish</code> helm chart in the <code>auth.github_accounts</code> key.</p>"},{"location":"getting-started/4-environment-adaptation/#other-properties","title":"Other properties","text":"<p>At this point the other properties of the <code>values.yaml</code> files (<code>sish</code>...) can be left as is.</p>"},{"location":"getting-started/4-environment-adaptation/#committing-current-configuration","title":"Committing current configuration","text":"<p>At this point you should commit the current configuration without forgetting to encrypt the secrets.</p> ShellPowerShell <pre><code>$ sops -e secrets/secrets.dec.yaml &gt; secrets/secrets.yaml\n$ rm secrets/secrets.dec.yaml\n$ git add values.yaml secrets/secrets.yaml\n$ git commit -m \"\ud83d\udd27 Platform values and secrets customization\"\n$\n</code></pre> <pre><code>PS&gt; sops -e secrets\\secrets.dec.yaml &gt; secrets\\secrets.yaml\nPS&gt; Remove-Item secrets/secrets.dec.yaml\nPS&gt; git add values.yaml secrets\\secrets.yaml\nPS&gt; git commit -m \"\ud83d\udd27 Platform values and secrets customization\"\nPS&gt;\n</code></pre>"},{"location":"getting-started/4-environment-adaptation/#applying-properties-to-kustomizations-and-applications","title":"Applying properties to kustomizations and applications","text":"<p>Apply the values to the current environment:</p> ShellPowerShell <pre><code>$ kustomize fn run --enable-exec packages\n$ kustomize fn run --enable-exec apps\n$ git status\nOn branch deploy/devenv\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git restore &lt;file&gt;...\" to discard changes in working directory)\nmodified:   apps/available/apisix.yaml\n        modified:   apps/available/applications-set.yaml\n        modified:   apps/available/argocd.yaml\n        modified:   apps/available/bootstrap.yaml\n        modified:   apps/available/cert-manager.yaml\n        modified:   apps/available/chisel-client.yaml\n        modified:   apps/available/external-dns-cloudflare.yaml\n        modified:   apps/available/external-dns-ovh.yaml\n        modified:   apps/available/ingresses.yaml\n        modified:   apps/available/sish.yaml\n        modified:   packages/argocd/argocd-cm.yaml\n        modified:   packages/argocd/autocloud-cm.yaml\n        modified:   packages/cert-manager/letsencrypt-issuer.yaml\n        modified:   packages/cloudflare-client/deployment.yaml\n        modified:   packages/external-dns-cloudflare/external-dns-configmap.yaml\n        modified:   packages/external-dns-cloudflare/external-dns-secret.yaml\n        modified:   packages/external-dns-ovh/external-dns-configmap.yaml\n        modified:   packages/external-dns-ovh/external-dns-secret.yaml\n        modified:   packages/ingresses/argocd-ingress-cloudflare.yaml\n        modified:   packages/ingresses/argocd-ingress.yaml\n        modified:   packages/sish-client/sish-client.yaml\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\"\n$ git commit -a -m \"\ud83d\udd27 Applied platform values to applications and packages\"\n$\n</code></pre> <pre><code>PS&gt; kustomize fn run --enable-exec packages\nPS&gt; kustomize fn run --enable-exec apps\nPS&gt; git status\nOn branch deploy/devenv\nChanges not staged for commit:\n(use \"git add &lt;file&gt;...\" to update what will be committed)\n(use \"git restore &lt;file&gt;...\" to discard changes in working directory)\nmodified:   apps/available/apisix.yaml\nmodified:   apps/available/applications-set.yaml\nmodified:   apps/available/argocd.yaml\nmodified:   apps/available/bootstrap.yaml\nmodified:   apps/available/cert-manager.yaml\nmodified:   apps/available/chisel-client.yaml\nmodified:   apps/available/external-dns-cloudflare.yaml\nmodified:   apps/available/external-dns-ovh.yaml\nmodified:   apps/available/ingresses.yaml\nmodified:   apps/available/sish.yaml\nmodified:   packages/argocd/argocd-cm.yaml\nmodified:   packages/argocd/autocloud-cm.yaml\nmodified:   packages/cert-manager/letsencrypt-issuer.yaml\nmodified:   packages/cloudflare-client/deployment.yaml\nmodified:   packages/external-dns-cloudflare/external-dns-configmap.yaml\nmodified:   packages/external-dns-cloudflare/external-dns-secret.yaml\nmodified:   packages/external-dns-ovh/external-dns-configmap.yaml\nmodified:   packages/external-dns-ovh/external-dns-secret.yaml\nmodified:   packages/ingresses/argocd-ingress-cloudflare.yaml\nmodified:   packages/ingresses/argocd-ingress.yaml\nmodified:   packages/sish-client/sish-client.yaml\nno changes added to commit (use \"git add\" and/or \"git commit -a\"\nPS&gt; git commit -a -m \"\ud83d\udd27 Applied platform values to applications and packages\"\nPS&gt;\n</code></pre>"},{"location":"getting-started/4-environment-adaptation/#selecting-the-applications-to-deploy-at-bootstrap","title":"Selecting the applications to deploy at bootstrap","text":"<p>To understand how the cluster is bootstrapped, please read the relevant section in the Architecture page.</p> <p>What we will do for now is just add or remove the symbolic links to applications manifests in the <code>apps/bootstrap</code> and <code>apps/default</code> directories to accommodate our setup.</p> <p>Taking K3s as an example, it provides out of the box the load balancer, storage class, metrics and ingress controller. In consequence, we don't need to deploy <code>uninode</code> nor <code>traefik</code>. We will remove them from bootstrap:</p> ShellPowerShell <pre><code>$ rm apps/bootstrap/{traefik,uninode}.yaml\n$\n</code></pre> <pre><code>PS&gt; @('traefik', 'uninode') | % { remove-item apps/bootstrap/$_.yaml }\nPS&gt;\n</code></pre> <p>Info</p> <p>The advantage of starting from a naked cluster is that the base services are managed by Argo CD and can be updated with gitops.</p> <p>In K3s, traefik is installed in the <code>kube-system</code> namespace while <code>uninode</code> installs it in the <code>traefik</code> namespace. In consequence, we need to adapt the domain names of the tunnels redirections:</p> <pre><code>--- a/packages/cloudflare-client/deployment.yaml\n+++ b/packages/cloudflare-client/deployment.yaml\n@@ -10,7 +10,7 @@ data:\n    credentials-file: /credentials/credentials.json\n     ingress:\n     - hostname: \"*.klasmik.com\"\n-      service: http://traefik.traefik.svc:80\n+      service: http://traefik.kube-system.svc:80\n    - service: http_status:404\n ---\n apiVersion: v1\n--- a/packages/sish-client/sish-client.yaml\n+++ b/packages/sish-client/sish-client.yaml\n@@ -37,7 +37,7 @@ data:\n      ServerAliveInterval 10\n       ServerAliveCountMax 2\n       RemoteCommand sni-proxy=true\n-      RemoteForward argocd-devenv.develop.cx:443 traefik.traefik.svc:443\n+      RemoteForward argocd-devenv.develop.cx:443 traefik.kube-system.svc:443\n  known_hosts: |\n     [develop.cx]:2222 ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAID+3abW2y3T5dodnI5O1Z/2KlIdH3bwnbGDvCFf13zlh\n ---\n</code></pre> <p>Once you have committed your changes and pushed the branch, proceed to the Cluster deployment.</p>"},{"location":"getting-started/5-cluster-deployment/","title":"Cluster deployment","text":""},{"location":"getting-started/5-cluster-deployment/#cluster-setup","title":"Cluster setup","text":"<p>As as example, we will use K3s. K3s is setup with the following command (see the k3s documentation):</p> <pre><code>&gt; curl -sfL https://get.k3s.io | sh -\n</code></pre> <p>For windows users, The howtos section tells how to quickly install k3s on Windows.</p>"},{"location":"getting-started/5-cluster-deployment/#pre-requisites","title":"Pre-requisites","text":"<p>From where you deploy autocloud, you will need:</p> <ul> <li>The credentials (SSH key) to access the git repository.</li> <li>The age key used to encrypt the secrets.</li> </ul> <p>You also need the following software:</p> <ul> <li>git</li> <li>kustomize</li> <li>kubectl</li> <li>krmfnbuiltin</li> </ul> <p>If you're deploying from the machine on which you performed the environment customization you should be good to go.</p>"},{"location":"getting-started/5-cluster-deployment/#deployment","title":"Deployment","text":"<p>Because this is GitOps, the bootstrapping is done by deploying what has been pushed:</p> ShellPowerShell <pre><code>$ kustomize build --enable-alpha-plugins --enable-exec \\\n&gt; \"git@github.com:klasmik/klasmikloud.git//packages/argocd/?ref=deploy/devenv\" \\\n&gt; | kubectl apply -f\n</code></pre> <pre><code>PS&gt; kustomize build --enable-alpha-plugins --enable-exec \\\n&gt; \"git@github.com:klasmik/klasmikloud.git//packages/argocd/?ref=deploy/devenv\" \\\n&gt; | kubectl apply '-f'\n</code></pre>"},{"location":"getting-started/5-cluster-deployment/#checking-deployment-status","title":"Checking deployment status","text":"<p>You can check the deployment status with the following command:</p> <pre><code>&gt;  kubectl -n argocd rollout status deployments,statefulsets,daemonsets --timeout=90s\ndeployment \"argocd-redis\" successfully rolled out\ndeployment \"argocd-applicationset-controller\" successfully rolled out\ndeployment \"argocd-dex-server\" successfully rolled out\ndeployment \"argocd-notifications-controller\" successfully rolled out\ndeployment \"argocd-repo-server\" successfully rolled out\ndeployment \"argocd-server\" successfully rolled out\npartitioned roll out complete: 1 new pods have been updated...\n&gt;\n</code></pre> <p>And then see the applications with the following command:</p> <pre><code>&gt; kubectl -n argocd get applications\nNAME                SYNC STATUS   HEALTH STATUS\nexternal-dns-ovh    Synced        Healthy\nsish-client         Synced        Healthy\ningresses           Synced        Healthy\ncloudflare-client   Synced        Healthy\napps                Synced        Healthy\nbootstrap           Synced        Healthy\ncert-manager        Synced        Healthy\nargo-cd             Synced        Healthy\n&gt;\n</code></pre> <p>Going to the configured URL (here https://argocd-devenv.klasmik.com/) should allow you to login:</p> <p></p> <p>You can login as admin or with your github account. You can then access the applications page:</p> <p></p>"},{"location":"howtos/k3s-windows-install/","title":"Install K3s on Windows","text":"<p>This how-to uses the alpine root filesystem of the Wsl-Manager project.</p>"},{"location":"howtos/k3s-windows-install/#pre-requisites","title":"Pre-requisites","text":"<p>You need to have WSL working on your machine. On recent Windows (11+), issue the command:</p> <pre><code>PS&gt; wsl --install\n...\n</code></pre> <p>More information is available in the Microsoft documentation.</p>"},{"location":"howtos/k3s-windows-install/#create-the-wsl-distribution","title":"Create the WSL distribution","text":"<p>First download the root filesystem and create the WSL distribution:</p> <pre><code>PS&gt; ([System.Net.WebClient]::new()).DownloadFile(\"https://github.com/antoinemartin/PowerShell-Wsl-Manager/releases/latest/download/miniwsl.alpine.rootfs.tar.gz\", \"$PWD/alpine.tgz\")\nPS&gt; wsl --import myk3s . alpine.tgz\nPS&gt;\n</code></pre>"},{"location":"howtos/k3s-windows-install/#install-k3s","title":"Install K3S","text":"<p>Connect to the WSL distribution and install K3s:</p> <pre><code>PS&gt; wsl -d myk3s\n[powerlevel10k] fetching gitstatusd .. [ok]\n\u276f\n# curl is needed\n&gt; apk add curl\n...\n# install K3s without starting it\n&gt;  curl -sfL https://get.k3s.io | sed -e 's/sourcex/./g' | INSTALL_K3S_SKIP_START=\"true\" sh -\n[INFO]  Finding release for channel stable\n[INFO]  Using v1.25.6+k3s1 as release\n[INFO]  Downloading hash https://github.com/k3s-io/k3s/releases/download/v1.25.6+k3s1/sha256sum-amd64.txt\n[INFO]  Downloading binary https://github.com/k3s-io/k3s/releases/download/v1.25.6+k3s1/k3s\n[INFO]  Verifying binary download\n[INFO]  Installing k3s to /usr/local/bin/k3s\n[INFO]  Skipping installation of SELinux RPM\n[INFO]  Creating /usr/local/bin/kubectl symlink to k3s\n[INFO]  Creating /usr/local/bin/crictl symlink to k3s\n[INFO]  Creating /usr/local/bin/ctr symlink to k3s\n[INFO]  Creating killall script /usr/local/bin/k3s-killall.sh\n[INFO]  Creating uninstall script /usr/local/bin/k3s-uninstall.sh\n[INFO]  env: Creating environment file /etc/rancher/k3s/k3s.env\n[INFO]  openrc: Creating service file /etc/init.d/k3s\n[INFO]  openrc: Enabling k3s service for default runlevel\n</code></pre> <p>You can now start K3s:</p> <pre><code># start openrc. K3s will start...\n&gt; openrc default\n * Caching service dependencies ...           [ ok ]\n* Starting k3s ...                           [ ok ]\n# List nodes\n&gt;  export KUBECONFIG=/etc/rancher/k3s/k3s.yaml\n &gt;  kubectl get nodes\nNAME              STATUS   ROLES                  AGE    VERSION\nlaptop-vkhdd5jr   Ready    control-plane,master   112s   v1.25.6+k3s1\n# Get deployment status\n&gt; kubectl -n kube-system rollout status deployments,statefulsets,daemonsets\ndeployment \"local-path-provisioner\" successfully rolled out\ndeployment \"coredns\" successfully rolled out\ndeployment \"traefik\" successfully rolled out\ndeployment \"metrics-server\" successfully rolled out\ndaemon set \"svclb-traefik-114ab381\" successfully rolled out\n&gt;\n</code></pre>"},{"location":"howtos/k3s-windows-install/#stop-k3s","title":"Stop K3S","text":"<p>To stop K3s properly, you need to use the <code>k3s-killall.sh</code> script:</p> <pre><code>PS&gt; wsl -d myk3s k3s-killall.sh\nPS&gt; wsl --terminate myk3s\n...\n</code></pre>"},{"location":"howtos/k3s-windows-install/#re-start-k3s","title":"Re-start K3s","text":"<p>To restart K3s, issue the following command:</p> <pre><code>PS&gt; wsl -d myk3s openrc default\n...\n</code></pre>"},{"location":"howtos/k3s-windows-install/#access-k3s-from-windows","title":"Access K3s from Windows","text":"<p>You can run <code>k3s kubectl</code> in the WSL distribution from Windows:</p> <pre><code>PS&gt; wsl -d myk3s k3s kubectl get pods -A\nNAMESPACE     NAME                                      READY   STATUS      RESTARTS   AGE\nkube-system   helm-install-traefik-crd-752lw            0/1     Completed   0          11m\nkube-system   helm-install-traefik-g68pt                0/1     Completed   1          11m\nkube-system   traefik-66c46d954f-6bmr6                  1/1     Running     0          11m\nkube-system   local-path-provisioner-79f67d76f8-wrpt4   1/1     Running     0          11m\nkube-system   svclb-traefik-114ab381-c2bql              2/2     Running     0          11m\nkube-system   metrics-server-5f9f776df5-pp6r6           1/1     Running     0          11m\nkube-system   coredns-597584b69b-hm8qq                  1/1     Running     0          11m\nPS&gt;\n</code></pre> <p>You can also integrate the k3s config in your current configuration:</p> <pre><code>PS&gt; # Point to the K3s kubeconfig\nPS&gt; $env:KUBECONFIG=\"\\\\wsl$\\myk3s\\etc\\rancher\\k3s\\k3s.yaml\"\nPS&gt;\nPS&gt; # Check that the context is here\nPS&gt; kubectl config get-contexts\nCURRENT   NAME      CLUSTER   AUTHINFO   NAMESPACE\n*         default   default   default\nPS&gt;\nPS&gt; # Rename the context\nPS&gt; kubectl config rename-context default myk3s\nContext \"default\" renamed to \"myk3s\".\nPS&gt;\nPS&gt;# Flatten with the current configuration\nPS&gt; $env:KUBECONFIG=\"$env:KUBECONFIG;$env:USERPROFILE/.kube/config\"\nPS&gt; kubectl config view --flatten &gt;config.new\nPS&gt;\nPS&gt; # Check that the contexts are there\nPS&gt; $env:KUBECONFIG=\"$PWD\\config.new\"\nPS&gt; kubectl config get-contexts\nCURRENT   NAME               CLUSTER                        AUTHINFO                                        NAMESPACE\n...\nkaweezle           kaweezle                       kaweezle\n*         myk3s              default                        default\nrancher-desktop    rancher-desktop                rancher-desktop\n...\nPS&gt;\nPS&gt; # Change the hostname\nPS&gt; (Get-Content .\\config.new | % { $_ -replace '127.0.0.1', 'localhost' }) | Set-Content config.new\nPS&gt;\nPS&gt; # Check everything is Ok\nPS&gt; kubectl get pods -A\nNAMESPACE     NAME                                      READY   STATUS      RESTARTS      AGE\nkube-system   helm-install-traefik-crd-752lw            0/1     Completed   0             42m\nkube-system   helm-install-traefik-g68pt                0/1     Completed   1             42m\nkube-system   svclb-traefik-114ab381-c2bql              2/2     Running     2 (32m ago)   42m\nkube-system   local-path-provisioner-79f67d76f8-wrpt4   1/1     Running     1 (32m ago)   42m\nkube-system   traefik-66c46d954f-6bmr6                  1/1     Running     1 (32m ago)   42m\nkube-system   coredns-597584b69b-hm8qq                  1/1     Running     1 (32m ago)   42m\nkube-system   metrics-server-5f9f776df5-pp6r6           1/1     Running     1 (32m ago)   42m\nPS&gt;\nPS&gt; # Move the file in the standard place\nPS&gt; Move-Item $env:USERPROFILE\\.kube\\config $env:USERPROFILE\\.kube\\config.bak\nPS&gt; Move-Item .\\config.new $env:USERPROFILE\\.kube\\config\nPS&gt;\nPS&gt; # Use it from the standard place\nPS&gt; $env:KUBECONFIG=$null\nPS&gt;  kubectl get nodes\nNAME              STATUS   ROLES                  AGE   VERSION\nlaptop-vkhdd5jr   Ready    control-plane,master   47m   v1.25.6+k3s1\nPS&gt;\n</code></pre>"},{"location":"user-guide/","title":"Introduction","text":"<p>This section documents the workflow with Autocloud.</p> <p>TODO</p> <p>Fill this page.</p>"},{"location":"user-guide/properties/","title":"Platform properties","text":"<p>The <code>values.yaml</code> file provides a convenient way to apply platform wide properties to the different elements of the repository.</p> <p>Instead of having Helm charts with templates hard to read and maintain, we keep simple kustomizations and provides structural transformations to modify them.</p> <p>The structural transformations are performed by KRM functions, and in particular by krmfnbuiltin that provides all kustomize builtin transformations and more.</p> <p>The customization works with the following elements:</p> <ul> <li>A <code>values.yaml</code> KRM resource file that contains the global properties of the     platform.</li> <li>A set of transformers configurations performing replacements of existing     values with the ones coming from <code>values.yaml</code>. Those configurations are     present in each package (<code>*-values-replacements.yaml</code> file) and in the     <code>apps/functions</code> directory.</li> </ul> <p>With this, the workflow is the following:</p> <ul> <li>Fork this repository or create a branch.</li> <li>Edit the <code>values.yaml</code> and change the properties according to the desired     configuration. In particular, change the <code>git.repoURL</code> and     <code>git.targetRevision</code> properties.</li> <li>Edit the <code>secrets/secrets.yaml</code> file accordingly (see secrets).</li> <li>Apply the configuration with the following commands:</li> </ul> <pre><code>&gt; kustomize fn run --enable-exec apps\n&gt; # Or do it on individual packages (packages/one, ...)\n&gt; kustomize fn run --enable-exec packages\n</code></pre> <ul> <li>Commit the current modifications:</li> </ul> <pre><code>&gt; git add -A &amp;&amp; git commit -m \"Apply new platform properties\"\n</code></pre> <p>And then from this point select the ArgoCD applications to install.</p>"},{"location":"user-guide/properties/#defining-properties","title":"Defining properties","text":"<p>Let's look at the <code>values.yaml</code> file header part:</p> <pre><code># values.yaml\napiVersion: autocloud.config.kaweezle.com/v1alpha1\n# Non standard kind to prevent application to a kubernetes cluster\nkind: PlatformValues\nmetadata:\n# We will use this name to \"source\" replacement values\nname: autocloud-values\nannotations:\n# Remove this at the end of the transformation\nconfig.kaweezle.com/local-config: 'true'\n# Tells krmfnbuiltin to inject this resource in the transformation\nconfig.kaweezle.com/inject-local: 'true'\n# Tells kustomize to use krmfnbuiltin as KRM function\nconfig.kubernetes.io/function: |\nexec:\npath: krmfnbuiltin\ndata:\n</code></pre> <p>It has a non standard kind <code>PlatformValues</code>. This will prevent it to be applied by mistake to a cluster. The <code>config.kubernetes.io/function</code> annotation tells kustomize to pipe the resources through krmfnbuiltin. <code>config.kaweezle.com/inject-local</code> tells krmfnbuiltin to just inject the contents of this configuration in the output so that the following transformations can reference it. Last, <code>config.kaweezle.com/local-config</code> annotation will allow us in the <code>zz_cleanup.yaml</code> transformations to remove the properties from the resources before saving them back to the directory.</p> <p>Now let's look at de <code>data</code> part of the file:</p> <pre><code>data:\ndata:\ncluster:\nid: autocloud\nuninode: true\n...\ngit:\nrepoURL: https://github.com/antoinemartin/autocloud.git\ntargetRevision: main\ngithub:\norganization: ...\n...\ncloudflare:\n...\novh:\n...\nsish:\n...\nchisel:\n...\n</code></pre> <p>You have several sections with some identifiers defined for each of them. Ideally, each property here is only defined once. You may use anchors if needed.</p>"},{"location":"user-guide/properties/#applying-the-properties","title":"Applying the properties","text":"<p>The properties are applied to a directory with the following command:</p> <pre><code>&gt; # on the root directory\n&gt; kustomize fn run --enable-exec DIR\n</code></pre> <p>Kustomize will apply the functions present in the <code>DIR</code> directory to itself, recursively.</p>"},{"location":"user-guide/properties/#important-ignoring-directories-and-files","title":"IMPORTANT: Ignoring directories and files","text":"<p><code>kustomize fn run</code> tries to interpret all files visited as KRM resources. But Helm Charts are not compliant, as well as some other files (patches...). It also reformats the files, and in particular remove blank lines. That's something that we don't want for instance with <code>kustomization.yaml</code> files.</p> <p>You can prevent a file or directory from being taken into account by adding it in <code>apps/.krmignore</code> or <code>packages/.krmignore</code>:</p> <pre><code># packages/.krmignore\n# Don't process kustomization and schema files\nkustomization.yaml\n# Helm Charts\nsish/\n# Extra\ncert-manager/cert-manager.yaml\n</code></pre> <p>Also, kustomize loads all resources before processing them. If two files contain a resource with the same id, it will complain that the resource has been added twice. In that case, first try to change the name of one of the resources. If this is not possible, add one of the files to <code>.krmignore</code>.</p>"},{"location":"user-guide/properties/#writing-package-replacements","title":"Writing package replacements","text":"<p>When you add a package configuration to the project, it is convenient to provide at the same time a replacement transformer configuration in order to allow others to simply branch and customize the project.</p> <p>The file containing the configuration should be named <code>*-values-replacements.yaml</code>.</p> <p>Your replacement function configuration should start with the following:</p> <pre><code># Selecting transformer kind in krmfnbuiltin\napiVersion: krmfnbuiltin.kaweezle.com/v1alpha1\nkind: ReplacementTransformer\nmetadata:\n# be a good KRM citizen, give it an explicit name\nname: argocd-replacement-transformer\nannotations:\n# Without this annotation, kustomize fn run will skip this function\nconfig.kubernetes.io/function: |\nexec:\npath: krmfnbuiltin\n# Source of the replacement\nsource: values.yaml\nreplacements:\n</code></pre> <p>Then it contains the structured replacements from the properties. Example:</p> <pre><code>- source:\nname: autocloud-values # (1)!\nfieldPath: data.github.clientID\ntargets:\n- select: # (2)!\nkind: ConfigMap\nname: argocd-cm\nfieldPaths:\n- data.dex\\.config.!!yaml.connectors.[id=github].config.clientID\n</code></pre> <ol> <li>At least name is required</li> <li>The same source can have multiple targets</li> </ol> <p>In the above, we get the <code>data.github.clientID</code> from the <code>values.yaml</code> file and inject it in the Argo CD config map. If the value is <code>myid</code>, the <code>packages/argocd/argocd-cm.yaml</code> file would be modified:</p> <pre><code>dex.config: |\nconnectors:\n# GitHub example\n- type: github\nid: github\nname: GitHub\nconfig:\nclientID: myid  # &lt;-- The modifications is here\nclientSecret: $dex.github.clientSecret\n</code></pre> <p>Please go to the krmfnbuiltin documentation for details.</p>"},{"location":"user-guide/properties/#replacement-guidelines","title":"Replacement guidelines","text":"<ul> <li>All replacements are performed each time the <code>kustomize fn run</code> command     is applied. In consequence, keep your <code>targets</code> as specific as possible. If     needed, you can add <code>annotationSelector</code> to select the proper resource kind     subset (see applications.yaml for instance).</li> <li>krmfnbuiltin provides an extended <code>ReplacementTransformer</code> that can make     complex replacements like regexp replacements in embedded yaml content     (<code>data.someValue.!!yaml.some.property.!!regex.property=(\\S+).1</code>). However,     these are hard to understand. It may be better to extract the value in a     config map and inject it in some other way (env variable...)</li> </ul>"},{"location":"user-guide/secrets/","title":"Secrets Kustomization","text":""},{"location":"user-guide/secrets/#rationale","title":"Rationale","text":"<p>Secrets management in gitops is not simple. There are, among others, several techniques:</p> <ul> <li>Having sops or sealed secrets encrypted secret files in the packages     configuration.</li> <li>Having replacement patterns in the source files and a tool to replace them     with the actual secret.</li> </ul> <p>Having secrets, encrypted or by reference spread in all the kustomizations makes the whole platform harder to maintain. Having replacement markers, would they be comments or Urls, is considered a bad practice.</p> <p>The objectives we pursue with this kustomization are the following:</p> <ul> <li>Have all the actual secrets centralized and encrypted in one place (this     kustomization, and in particular the <code>secrets.yaml</code> file).</li> <li>Keep the overlay principle of kustomize. That means that before     kustomization, all the package resources, including secrets, are actual     resources containing actual values, not placeholders. The only thing is that     the secrets resources contain fake secrets.</li> <li>Provide a way to replace the secrets with the actual values when building     the configurations. This is done through the kustomize plugin     krmfnbuiltin.</li> </ul> <p>So all secrets (api keys, client secrets, ...) present in secrets resources of the packages available in <code>packages/*</code>are actually fake secrets. When the secret is a password, it is simply <code>password</code>.</p> <p>The basic workflow with this kustomization when using secrets is the following:</p> <ul> <li>Decrypt the secrets file.</li> <li>Add the secret to the file.</li> <li>Encrypt the secret file.</li> <li>On the kustomization where the secret is used, use the <code>krmfnbuiltin</code> <code>ReplacementTransformer</code> with this kustomization as <code>source</code> to replace the     fake secret by the actual secret.</li> </ul>"},{"location":"user-guide/secrets/#pre-requisites","title":"Pre-requisites","text":"<ul> <li>sops</li> <li>age</li> <li>krmfnbuiltin</li> </ul>"},{"location":"user-guide/secrets/#encryption-key-setup","title":"Encryption key setup","text":"<p>The following script shows how to create an new key for secrets encryption and replace the sample key:</p> <pre><code># Create a directory to contain keys\nmkdir -p  ~/.config/sops/age\n# Copy the sample key\ncp sample_age_key.txt &gt;~/.config/sops/age/keys.txt\n# Generate a new key\nage-keygen &gt;&gt;~/.config/sops/age/keys.txt\n# get keys recipients\nOLDRECIPIENT=$(age-keygen -y ~/.config/sops/age/keys.txt | head -1)\nNEWRECIPIENT=$(age-keygen -y ~/.config/sops/age/keys.txt | tail -1)\n# rotate keys\nfor f in secrets/secrets.yaml secrets/helm/*; do\nsops -r -i --add-age $NEWRECIPIENT --rm-age $OLDRECIPIENT $f\ndone\n# set new recipient when encrypting\nsed -i -e \"s/age: .*/age: $NEWRECIPIENT/\" .sops.yaml\n# remove old key\nrm sample_age_key.txt\nsed -i -e '1,3 d' ~/.config/sops/age/keys.txt\n# commit modifications\ngit add -A &amp;&amp; git commit -m \"Changed encryption key\"\n</code></pre>"},{"location":"user-guide/secrets/#usage","title":"Usage","text":"<p>When a package needs a secret, decrypt the secrets file with the command:</p> <pre><code>&gt; sops -d secrets/secrets.yaml &gt; secrets/secrets.dec.yaml\n</code></pre> <p>Add the secret to the <code>secrets.dec.yaml</code> file. You can use hierarchy:</p> <pre><code># secrets/secrets.yaml\napiVersion: autocloud.config.kaweezle.com/v1alpha1\nkind: SopsGenerator\nmetadata:\nname: autocloud-secrets\nannotations:\nconfig.kubernetes.io/function: |\nexec:\npath: krmfnbuiltin\ndata:\ncloudflare:\ncredentials.json: |\n...\novh:\napplication_secret: ...\nconsumer_key: ...\n</code></pre> <p>Encrypt the file and remove the unencrypted file:</p> <pre><code>&gt; sops -e  secrets/secrets.dec.yaml &gt; secrets/secrets.yaml\n&gt; rm -f secrets/secrets.dec.yaml\n</code></pre> <p>NOTE: <code>secrets/secrets.dec.yaml</code> is in <code>.gitignore</code>, so there is little risk that you commit the unencrypted file. However, keeping the unencrypted file on your disk is a security risk.</p> <p>You can check that everything is ok by building the kustomization. It should give you the unencrypted secrets provided the right key is present in <code>~/.config/sops/age/keys.txt</code>:</p> <pre><code>&gt; kustomize build --enable-alpha-plugins --enable-exec secrets # unencrypted secrets will follow\napiVersion: config.kaweezle.com/v1alpha1\ndata:\n  argocd:\n  ...\n</code></pre> <p>In the kustomization package where the secret is being used, you need to:</p> <ul> <li>Create a <code>krmfnbuiltin</code> <code>ReplacementTransformer</code> configuration to inject the     secrets at the right place.</li> <li>Add this transformer configuration to the <code>transformers:</code> section of your     <code>kustomization.yaml</code> file</li> </ul> <p>This is for example the secrets injection for the cloudflare client kustomization:</p> <pre><code># packages/cloudflare-client/cloudflare-client-secrets-replacements.yaml\napiVersion: krmfnbuiltin.kaweezle.com/v1alpha1 # &lt;-- avoid builtin\nkind: ReplacementTransformer\nmetadata:\nname: cloudflare-client-secrets-replacements\nannotations:\nconfig.kubernetes.io/function: |\nexec:\npath: krmfnbuiltin\nsource: ../../secrets # &lt;-- source kustomization. Secrets will come unencrypted from it.\nreplacements:\n# These are the replacements\n- source:\nname: autocloud-secrets\nfieldPath: data.cloudflare.credentials\\.json\ntargets:\n- select:\nkind: Secret\nname: cloudflared\nfieldPaths:\n- stringData.credentials\\.json\n</code></pre> <p>And how it is integrated:</p> <pre><code># kustomization.yaml\ntransformers:\n- cloudflare-client-secrets-replacements.yaml\n</code></pre> <p>Remark: To keep the transformation for building and avoid kustomize picking it while doing <code>kustomize fn run</code>, add the file to <code>.krmignore</code>:</p> <pre><code>#.krmignore\n*-secrets-replacements.yaml\n</code></pre>"},{"location":"user-guide/secrets/#possible-evolutions","title":"Possible evolutions","text":"<ul> <li> Have several secret files, one per concern (OVH, Cloudflare, ...). Would         also allow to use different encryption keys.</li> </ul>"}]}